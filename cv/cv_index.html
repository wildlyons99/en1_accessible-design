<html>
<head>
	<title>Score Image Processing</title>
    <!-- Based on work by Dr. Danahy <tufts.edu> -->
    <!-- NMStiegler <- github -->
	<!-- this is the script include that links to the OpenCV.js code -->
	<script type="text/javascript" src="https://docs.opencv.org/master/opencv.js"></script>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <!-- CEEO Script -->
    <script src="https://cdn.jsdelivr.net/gh/tuftsceeo/SPIKE-Web-Interface/cdn/ServiceDock.js" charset="utf-8"></script>
    <!-- Link to Airtable JS stuff -->
	<script src="../src/secret.js" charset="utf-8"></script>
	<script src="../src/cloud.js" charset="utf-8"></script>
    <!-- link to style.css -->
	<link rel="stylesheet" href="../src/style.css" />
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
</head>
<body>
    <!-- SERVICE DOCK -->
    <div id="servicedock">
        <service-airtable id="service_airtable" tablename="shuffle"></service-airtable>
    </div>
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
     <div class="container-fluid center" >
        <div class="row">
            <div class="col-lg-6">
                <h2>Start Video</h2>
                
                <blockquote>
                
                    <p>Set up the "video canvas" and stream the camera to it.</p>
                    
                    <script language="javascript">
                        // global variables to hold the SIZE of the input
                        var input_width = 640;
                        var input_height = 480;
                        
                        function start_video(video_id) {
                            var video_canvas = document.getElementById(video_id);
                            // Set the width and height:
                            video_canvas.setAttribute("width", input_width);
                            video_canvas.setAttribute("height", input_height);
                            // Get access to the camera!
                            if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                // Not adding `{ audio: true }` since we only want video now
                                navigator.mediaDevices.getUserMedia({ video: true }).then(function(stream) {
                                    video_canvas.srcObject = stream;
                                    video_canvas.play();
                                });
                            }
                        }
                    </script>
                
                    <p><button onclick="start_video('video');">Start Video</button></p>

                    <video id="video" autoplay style="border: black solid 1px;"></video>

                </blockquote>
            </div>
            <div class="col-md-3">
                <h2>Draw circle with center at biggest radius detected circle</h2>
                
                <blockquote>

                    <script>
                        // going to use BINARY image created in previous step
                        // find the coutours in the image
                        // and then draw them (back onto the grayscale image)
                        function draw_enclosing_circle(src_binary_id, src_canvas_id, dst_canvas_id, color) {
                            // set up dst canvas
                            var dst_canvas = document.getElementById(dst_canvas_id);
                            dst_canvas.setAttribute("width", output_width);
                            dst_canvas.setAttribute("height", output_height);
                            
                            // read in BINARY image
                            var binary_img = cv.imread(src_binary_id);
                            // make sure binary (convert to grayscale and threshold)
                            cv.cvtColor(binary_img, binary_img, cv.COLOR_RGBA2GRAY);
                            cv.threshold(binary_img, binary_img, 128, 255, cv.THRESH_BINARY);
                            // read in grayscale image
                            var dst = cv.imread(src_canvas_id);
                            // convert src to grayscale and then BACK to RGB (since going to draw on it in color)
                            cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
                            cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                                            
                            // setup
                            // let contours = new cv.MatVector();
                            // let hierarchy = new cv.Mat();
                            
                            
                            // var biggestVector = 0;
                            // var biggestVectorRadius = 0;

                            // // find contours
                            // cv.findContours(binary_img, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                            // console.log('- FOUND', contours.size(), 'contours');

                            // // go through contours
                            // if (contours.size() > 0) {
                            //     // we are going to draw the contours in YELLOW
                            //     // - create yellow color (255, 255, 0, 255)
                            //     let yellow_color = new cv.Scalar(255, 255, 0, 255);
                            //     // go through each contour:
                            //     for (var i=0; i<contours.size(); i++) {
                            //         //cv.drawContours(dst, contours, i, yellow_color, 2, cv.LINE_8, hierarchy, 100);
                                    
                            //         // note: you can find the "minimum enclosing circle" around the contour
                            //         // see: https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html
                            //         let circle = cv.minEnclosingCircle(contours.get(i));
                            //         // this circle has:
                            //         // - location: circle.center
                            //         // - radius: circle.radius
                            //         // so if it's big (radius > 10) then print to console:
                            //         console.log(' - circle at', circle.center, 'has radius', circle.radius);

                            //         // finds biggest circle
                            //         if (circle.radius > biggestVectorRadius) {
                            //             biggestVector = i;
                            //             biggestVectorRadius = circle.radius;
                            //         }
                            // }
                                
                                // gets list enclosing circles of 4 largest objects in analyzed color
                                var minSize = document.getElementById('demo1').innerHTML;
                                var maxSize = document.getElementById('demo2').innerHTML;

                                var contourList = find_objects(binary_img, 4, minSize, maxSize);

                                let yellow_color = new cv.Scalar(255, 255, 0, 255);

                                
                                // defines width and height of calculated areas
                                let score_rows = 4;
                                let score_columns = 4;
                                var score_width = output_width/score_columns;
                                var score_height = output_height/score_rows;

                                //draws this many rows and columns on image
                                for (var i=0; i<score_columns; i++) {
                                    for (var j=0; j<score_rows; j++){
                                        cv.rectangle(dst, {x: i*score_width, y:j*score_height}, {x: score_width*(i+1), y: score_height*(j+1)}, yellow_color, 1);
                                    }
                                }



                                //x and y are top left corner of the area
                                //width of areas are score_width & score_height
                                var score_areas = [
                                    {x: 0, y: 0, points: document.getElementById('1x1').value}, {x: score_width, y: 0, points: document.getElementById('1x2').value}, {x: 2*score_width, y: 0, points: document.getElementById('1x3').value}, {x: 3*score_width, y: 0, points: document.getElementById('1x4').value},
                                    {x: 0, y: score_height, points: document.getElementById('2x1').value}, {x: score_width, y: score_height, points: document.getElementById('2x2').value}, {x: 2*score_width, y: score_height, points: document.getElementById('2x3').value}, {x: 3*score_width, y: score_height, points: document.getElementById('2x4').value},
                                    {x: 0, y: 2*score_height, points: document.getElementById('3x1').value}, {x: score_width, y: 2*score_height, points: document.getElementById('3x2').value}, {x: 2*score_width, y: 2*score_height, points: document.getElementById('3x3').value}, {x: 3*score_width, y: 2*score_height, points: document.getElementById('3x4').value},
                                    {x: 0, y: 3*score_height, points: document.getElementById('4x1').value}, {x: score_width, y: 3*score_height, points: document.getElementById('4x2').value}, {x: 2*score_width, y: 3*score_height, points: document.getElementById('4x3').value}, {x: 3*score_width, y: 3*score_height, points: document.getElementById('4x4').value}
                                ];

                                var player_points = 0;
                                //for every found circle
                                for (var i=0; i<contourList.length; i++) {
                                    //console.log('radius', i, 'is', contourList[i].radius);
                                    //console.log('center', i, 'is', contourList[i].center);
                                    //draws enclosing circle & center
                                    var thisCircle = contourList[i];
                                    cv.circle(dst, thisCircle.center, thisCircle.radius, yellow_color, 2); //draws circle
                                    cv.circle(dst, thisCircle.center, 1, yellow_color, 1); // draws center
                                    font = cv.FONT_HERSHEY_SIMPLEX
                                    cv.putText(dst, Math.round(thisCircle.radius).toString(), {x: thisCircle.center.x - thisCircle.radius, y: thisCircle.center.y + thisCircle.radius}, font, 0.5, yellow_color, 2, cv.LINE_AA)
                                    //searches through all score areas (score_areas[j])until it finds which one the puck is in, then gives score accordingly
                                    for (var j=0; j<score_areas.length; j++){
                                        var score_object = score_areas[j];
                                        if (score_object.x < contourList[i].center.x && contourList[i].center.x < score_object.x + score_width && score_object.y < contourList[i].center.y && contourList[i].center.y < score_object.y + score_height){
                                            player_points = player_points + parseInt(score_object.points);
                                        }
                                    }

                                }
                                //update visible score
                                //console.log(player_points);
                                if (color == 'red'){red_output.innerHTML=player_points;}
                                if (color == 'blue'){blue_output.innerHTML=player_points;}

                                // let biggestCircle = cv.minEnclosingCircle(contours.get(biggestVector));
                                // var biggestCircleRadius = biggestCircle.radius;
                                // var biggestCircleCenter = biggestCircle.center;
                                // // console.log('type is', typeof(biggestCircleCenter))
                                // // console.log(biggestCircleCenter.x)

                                // console.log('biggest circle is', biggestVector, 'at', biggestCircleCenter, 'with radius', biggestCircleRadius);

                                // // draws biggest circle on image
                                // cv.circle(dst, biggestCircleCenter, biggestCircleRadius, yellow_color, 3); // thickness of 3
                                // // draws center point
                                // //cv.circle(dst, biggestCircleCenter, 1, yellow_color, 1); // thickness of 3
                                // //draws cross at center
                                // let point1 = new cv.Point(biggestCircleCenter.x - 3, biggestCircleCenter.y);
                                // let point2 = new cv.Point(biggestCircleCenter.x + 3, biggestCircleCenter.y);
                                // cv.line(dst, point1, point2, yellow_color, 1, cv.LINE_AA, 0);

                                // let point3 = new cv.Point(biggestCircleCenter.x, biggestCircleCenter.y - 3);
                                // let point4 = new cv.Point(biggestCircleCenter.x, biggestCircleCenter.y + 3);
                                // cv.line(dst, point3, point4, yellow_color, 1, cv.LINE_AA, 0);



                            
                            // display image with contours
                            cv.imshow(dst_canvas, dst);
                            // clean up tmp images created:
                            binary_img.delete();
                            dst.delete();
                            return player_points;
                        }

                        // takes in img_in
                        // max objects is n number of disks you're looking for
                        // min_size is a radius value

                        function find_objects(img_in, max_objects, min_size, max_size) {
                            // setup
                            let contours = new cv.MatVector();
                            let hierarchy = new cv.Mat();
                            let contour_list = []; // tmp empty array for holding list
                            
                            // find contours
                            cv.findContours(img_in, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                            // go through contours
                            if (contours.size() > 0) {
                                for (i=0; i<contours.size(); i++) {
                                    // check size
                                    var circle = cv.minEnclosingCircle(contours.get(i));
                                    if (circle.radius >= min_size && circle.radius <= max_size) {
                                        // push object into our array
                                        contour_list.push(circle);
                                    }
                                }
                                // sort results, biggest to smallest
                                // code via: https://flaviocopes.com/how-to-sort-array-of-objects-by-property-javascript/
                                contour_list.sort((a,b) => (a.radius > b.radius) ? -1 : 1);
                            } else {
                                // NO CONTOURS FOUND
                                //console.log('NO CONTOURS FOUND');
                            }

                            // return, from sorted list, those that match
                            return contour_list.slice(0, max_objects); // return the biggest ones
                        }


                    </script>
                    <script>
                        var analyzing;

                        function resetAnalyzing() {
                            clearInterval(analyzing);
                        }

                        function repeatRed(){
                            //resetAnalyzing();
                            analyzing = setInterval(analyzeRed, 500);
                        }


                        function repeatBlue(){
                            //resetAnalyzing();
                            analyzing = setInterval(analyzeBlue, 500);
                        }

                        function analyzeRed(){
                            display_frame('video', 'out1'); threshold_rgb('out1', 'red1', 'green1', 'blue1'); cloud_update('P1_Score', draw_enclosing_circle('red1', 'out1', 'bigCircle', 'red'));;
                        }
                        function analyzeBlue(){
                            display_frame('video', 'out1'); threshold_rgb('out1', 'red1', 'green1', 'blue1'); cloud_update('P2_Score', draw_enclosing_circle('blue1', 'out1', 'bigCircle', 'blue'));
                        }


                    </script>
                    <p>
                        <button onclick="repeatRed()">Analyze Red</button>
                        <button onclick="repeatBlue()">Analyze Blue</button>
                        <button onclick="resetAnalyzing()">Stop</button>
                        Score: <span style="color:red;" id='red_output'></span> - <span style="color:blue;" id='blue_output'></span>
                    </p>
                    
                    <canvas id="bigCircle" style="border: black solid 1px;"></canvas>
                    
                </blockquote>
                <br>
                <p class="center"> <button id="win_check"> Force Win Check </button> </p>
                
                <script>
                    document.getElementById("win_check").addEventListener('click', call_win)
                    
                    function call_win() {
                        cloud_update('Win_Force', 'Won')
                    }
                    
                </script>
            </div>
        </div>
    </div>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <div class="center slidecontainer">
    <p><b>Threshold</b></p>
    <input type="range" min="1" max="100" value="30" class="slider center cvSlider" id="threshRange">
    <p>Value: <span id="demo"></span></p>
    <p><b>Min Size of Circle</b></p>
    <input type="range" min="1" max="100" value="20" class="slider center cvSlider" id="minSizeRange">
    <p>Value: <span id="demo1"></span></p>
    <p><b>Max Size of Circle</b></p>
    <input type="range" min="1" max="100" value="40" class="slider center cvSlider" id="maxSizeRange">
    <p>Value: <span id="demo2"></span></p>
    </div>
    <div class='center tablecontainer'>
        <table class='center'>
            <tr>
                <td><input value='8' id='1x1' type="number"></td>
                <td><input value='2' id='1x2' type="number"></td>
                <td><input value='2' id='1x3' type="number"></td>
                <td><input value='8' id='1x4' type="number"></td>
            </tr>
            <tr>
                <td><input value='2' id='2x1' type="number"></td>
                <td><input value='10' id='2x2' type="number"></td>
                <td><input value='10' id='2x3' type="number"></td>
                <td><input value='2' id='2x4' type="number"></td>
            </tr>
            <tr>
                <td><input value='2' id='3x1' type="number"></td>
                <td><input value='10' id='3x2' type="number"></td>
                <td><input value='10' id='3x3' type="number"></td>
                <td><input value='2' id='3x4' type="number"></td>
            </tr>
            <tr>
                <td><input value='8' id='4x1' type="number"></td>
                <td><input value='2' id='4x2' type="number"></td>
                <td><input value='2' id='4x3' type="number"></td>
                <td><input value='8' id='4x4' type="number"></td>
            </tr>
        </table>
    </div>
    <script>
        var threshold = document.getElementById("threshRange");
        var minSize = document.getElementById('minSizeRange');
        var maxSize = document.getElementById('maxSizeRange');
        var output = document.getElementById("demo");
        var output1 = document.getElementById("demo1");
        var output2 = document.getElementById("demo2");
        output.innerHTML = threshold.value; // Display the default slider value
        output1.innerHTML = minSizeRange.value; // Display the default slider value
        output2.innerHTML = maxSizeRange.value; // Display the default slider value

        // Update the current slider value (each time you drag the slider handle)
        threshold.oninput = function() {
            output.innerHTML = this.value;
        }
        minSize.oninput = function() {
            output1.innerHTML = this.value;
        }
        maxSize.oninput = function() {
            output2.innerHTML = this.value;
        }
    </script>
    <div class="container-fluid center-block center">
        <p class='center'><h1 class='center'>Behind the Scenes</h1></p>
        <h2>Grab Frame and Display (and returns image data!)</h2>
        
        <blockquote>
            
            <p>See: <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage">DrawImage</a>.</p>
            
            <script>
                // global variables to hold the SIZE of the output
                var output_width = 320;
                var output_height = 240;
                
                // takes video data and displays on a canvas
                function display_frame(src_canvas_id, dst_canvas_id) {
                    // source canvas
                    var src_canvas = document.getElementById(src_canvas_id);
                    // set size of destination:
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);
                    // create output canvas context
                    dst_canvas_context = dst_canvas.getContext('2d');
                    // draw src onto dst
                    // see: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
                    dst_canvas_context.drawImage(src_canvas, 0, 0, output_width, output_height);
                    // return the image data
                    return cv.imread(dst_canvas_id);
                }
            </script>
            
            <p><button onclick="display_frame('video', 'out1');">Grab Frame</button></p>

            <canvas id="out1" style="border: black solid 1px;"></canvas>
            
        </blockquote>

        <!-- <h2>Change Values</h2>
        
        <blockquote>
            
            <script>
                // take one canvas, and get data
                // update values
                // display output onto another canvas
                function change_values(src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);

                    // get data from src canvas:
                    var img = cv.imread(src_canvas_id);

                    // go through all the pixels
                    // - use += 4 to "jump every fourth value"
                    //   because data is R, G, B, A in array
                    for (var i=0; i<img.data.length; i+=4) {
                        var r = img.data[i];   // red
                        var g = img.data[i+1]; // green
                        var b = img.data[i+2]; // blue
                        var a = img.data[i+3]; // alpha
                        // if pixel is bright, make BRIGHT WHITE (255, 255, 255)
                        var threshold = 150;
                        if (r > threshold && g > threshold && b > threshold) {
                            img.data[i] = 255;   // set red to 255
                            img.data[i+1] = 255; // set green to 255
                            img.data[i+2] = 255; // set blue to 255
                        }
                    }

                    // now display the new image
                    cv.imshow(dst_canvas_id, img);
                    // clean up tmp image created
                    img.delete();
                }
            </script>

            <p><button onclick="change_values('out1', 'out2');">Change Values</button></p>

            <canvas id="out2" style="border: black solid 1px;"></canvas>
            
        </blockquote> -->

        <!-- <h2>Change Colorspace</h2>
        
        <blockquote>
            <p>See:
                <ul><li><a href="https://docs.opencv.org/3.4/db/d64/tutorial_js_colorspaces.html">Changing Colorspaces</a></li></ul>
            </p>
            
            <script>
                // change colorspace from color to grayscale
                // note: result is now array of values 0->255 for each pixel
                function make_grayscale(src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);

                    // get data from src canvas:
                    var img = cv.imread(src_canvas_id);
                    // create a destination:
                    dst = new cv.Mat(); // set up temporary image
                    // convert color, see: https://docs.opencv.org/3.4/db/d64/tutorial_js_colorspaces.html
                    cv.cvtColor(img, dst, cv.COLOR_RGBA2GRAY); // convert image to grayscale
                    
                    // display grayscale image
                    cv.imshow(dst_canvas_id, dst);
                    // clean up tmp images created:
                    img.delete();
                    dst.delete();
                }
            </script>

            <p><button onclick="make_grayscale('out1', 'out3');">Make Grayscale</button></p>
            
            <canvas id="out3" style="border: black solid 1px;"></canvas>
            
        </blockquote> -->

        <!-- <h2>Detecting Red</h2>
        
        <blockquote>
            
            <p>A pixel (in RGB color space) is "red" if the red-component is high AND both the green and blue components are low.</p>
            
            <p>(If "red" is high AND one of the others is too, then it's not pure red!  If all three are, then it's almost white!)</p>
            
            <script>
                // detect red algorithm:
                // - create a grayscale image that matches the original
                // - go through the original pixels
                //   > if the pixel is red (high R, low G, low B), then keep the grayscale version
                //   > else, set the grayscale version to black (0)
                function detect_red(src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);

                    // get data from src canvas:
                    var img = cv.imread(src_canvas_id);
                    // create a destination:
                    dst = new cv.Mat(); // set up temporary image
                    // convert color, see: https://docs.opencv.org/3.4/db/d64/tutorial_js_colorspaces.html
                    cv.cvtColor(img, dst, cv.COLOR_RGBA2GRAY); // convert image to grayscale
                    
                    // now we have:
                    // - img: original image (R,G,B,A)
                    // - dst: grayscale destination image
                    // look for RED and keep those values
                    // else set to zero (black)
                    for (var i=0; i<img.data.length; i+=4) {
                        var r = img.data[i];   // red
                        var g = img.data[i+1]; // green
                        var b = img.data[i+2]; // blue
                        var a = img.data[i+3]; // alpha
                        // check if red:
                        // - difference between red & green is big and between red & blue is big
                        var threshold = 70;
                        var grayscale_pixel_location = parseInt(i/4);
                        if (r - g > threshold && r - b > threshold) {
                            // pixel is very red, so leave it
                        } else {
                            // pixel is NOT very red, so set to black
                            dst.data[grayscale_pixel_location] = 0;
                        }
                    }

                    // display modified grayscale image
                    cv.imshow(dst_canvas_id, dst);
                    // clean up tmp images created:
                    img.delete();
                    dst.delete();
                }
            </script>
            
            <p><button onclick="detect_red('out1', 'out4');">Detect Red</button></p>

            <canvas id="out4" style="border: black solid 1px;"></canvas>
            
        </blockquote> -->
        
        <h2>Thresholding (and R, G, B)</h2>
        
        <blockquote>
            
            <p>See:
                <ul><li><a href="https://docs.opencv.org/3.4/d7/dd0/tutorial_js_thresholding.html">Image Thresholding</a></li></ul>
            </p>
            
            <p>Thresholding creates a binary image (each pixel is black or white) based on some threshold value:
                <ul>
                    <li>if a pixel is above a threshold, then it is set to white</li>
                    <li>otherwise (pixel is below a threshold), it is set to black</li>
                </ul>
            </p>
            
            <p>Note: you should probably make the threshold different for R, G, and B based on lighting, camera, etc.</p>
            
            <script>
                function threshold_rgb(src_canvas_id, red_canvas_id, green_canvas_id, blue_canvas_id) {
                    // set up dst canvases
                    var red_canvas = document.getElementById(red_canvas_id);
                    red_canvas.setAttribute("width", output_width);
                    red_canvas.setAttribute("height", output_height);
                    var green_canvas = document.getElementById(green_canvas_id);
                    red_canvas.setAttribute("width", output_width);
                    red_canvas.setAttribute("height", output_height);
                    var blue_canvas = document.getElementById(blue_canvas_id);
                    red_canvas.setAttribute("width", output_width);
                    red_canvas.setAttribute("height", output_height);

                    // get data from src canvas:
                    var img = cv.imread(src_canvas_id);
                    // create destination images:
                    r_dst = new cv.Mat();
                    cv.cvtColor(img, r_dst, cv.COLOR_RGBA2GRAY); // convert image to grayscale
                    g_dst = new cv.Mat();
                    cv.cvtColor(img, g_dst, cv.COLOR_RGBA2GRAY); // convert image to grayscale
                    b_dst = new cv.Mat();
                    cv.cvtColor(img, b_dst, cv.COLOR_RGBA2GRAY); // convert image to grayscale

                    var threshold = document.getElementById("demo").innerHTML; // SAME THRESHOLD FOR ALL
                    //console.log(threshold);
                    for (var i=0; i<img.data.length; i+=4) {
                        var r = img.data[i];   // red
                        var g = img.data[i+1]; // green
                        var b = img.data[i+2]; // blue
                        var a = img.data[i+3]; // alpha
                        var grayscale_pixel_location = parseInt(i/4);
                        // check if red (difference between red & green is big and between red & blue is big)
                        if (r - g > threshold && r - b > threshold) {
                            // pixel is red, make WHITE
                            r_dst.data[grayscale_pixel_location] = 255;
                        } else {
                            // pixel is NOT very red, make BLACK
                            r_dst.data[grayscale_pixel_location] = 0;
                        }
                        // check if green (difference between green & red is big and between green & blue is big)
                        if (g - r > threshold && g - b > threshold) {
                            // pixel is green, make WHITE
                            g_dst.data[grayscale_pixel_location] = 255;
                        } else {
                            // pixel is NOT very green, make BLACK
                            g_dst.data[grayscale_pixel_location] = 0;
                        }
                        // check if blue (difference between blue & red is big and between blue & green is big)
                        if (b - r > threshold && b - g > threshold) {
                            // pixel is red, make WHITE
                            b_dst.data[grayscale_pixel_location] = 255;
                        } else {
                            // pixel is NOT very red, make BLACK
                            b_dst.data[grayscale_pixel_location] = 0;
                        }
                    }
                    
                    // THRESHOLD the GRAYSCALE IMAGES
                    // - convert to binary images
                    // - use same input & destination and 128->255 range
                    cv.threshold(r_dst, r_dst, 128, 255, cv.THRESH_BINARY);
                    cv.threshold(g_dst, g_dst, 128, 255, cv.THRESH_BINARY);
                    cv.threshold(b_dst, b_dst, 128, 255, cv.THRESH_BINARY);

                    // display modified grayscale images
                    cv.imshow(red_canvas_id, r_dst);
                    cv.imshow(green_canvas_id, g_dst);
                    cv.imshow(blue_canvas_id, b_dst);
                    // clean up tmp images created:
                    img.delete();
                    r_dst.delete();
                    g_dst.delete();
                    b_dst.delete();
                }
            </script>

            <p><button onclick="threshold_rgb('out1', 'red1', 'green1', 'blue1');">Threshold RGB</button></p>

            <p>
                Red:<br />
                <canvas id="red1" style="border: black solid 1px;"></canvas><br />
                Green:<br />
                <canvas id="green1" style="border: black solid 1px;"></canvas><br />
                Blue:<br />
                <canvas id="blue1" style="border: black solid 1px;"></canvas><br />
            </p>
            
        </blockquote>

        <!-- <h2>Find Object</h2>
        
        <blockquote>
            
            <p>See:
                <ul><li><a href="https://docs.opencv.org/3.4/d0/d43/tutorial_js_table_of_contents_contours.html">Coutours in OpenCV.js</a></li></ul>
            </p>

            <script>
                // going to use BINARY image created in previous step
                // find the coutours in the image
                // and then draw them (back onto the grayscale image)
                function find_contours(src_binary_id, src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);
                    
                    // read in BINARY image
                    var binary_img = cv.imread(src_binary_id);
                    // make sure binary (convert to grayscale and threshold)
                    cv.cvtColor(binary_img, binary_img, cv.COLOR_RGBA2GRAY);
                    cv.threshold(binary_img, binary_img, 128, 255, cv.THRESH_BINARY);
                    // read in grayscale image
                    var dst = cv.imread(src_canvas_id);
                    // convert src to grayscale and then BACK to RGB (since going to draw on it in color)
                    cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                                    
                    // setup
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    
                    // find contours
                    cv.findContours(binary_img, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                    console.log('- FOUND', contours.size(), 'contours');
                    
                    // go through contours
                    if (contours.size() > 0) {
                        // we are going to draw the contours in YELLOW
                        // - create yellow color (255, 255, 0, 255)
                        let yellow_color = new cv.Scalar(255, 255, 0, 255);
                        // go through each contour:
                        for (var i=0; i<contours.size(); i++) {
                            cv.drawContours(dst, contours, i, yellow_color, 2, cv.LINE_8, hierarchy, 100);
                            
                            // note: you can find the "minimum enclosing circle" around the contour
                            // see: https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html
                            let circle = cv.minEnclosingCircle(contours.get(i));
                            // this circle has:
                            // - location: circle.center
                            // - radius: circle.radius
                            // so if it's big (radius > 10) then print to console:
                            console.log(' - circle at', circle.center, 'has radius', circle.radius);
                        }
                    }
                    
                    // display image with contours
                    cv.imshow(dst_canvas, dst);
                    // clean up tmp images created:
                    binary_img.delete();
                    dst.delete();
                }
                
            </script>

            <p>
                <button onclick="find_contours('red1', 'out1', 'contours');">Find Red Contours</button>
                <button onclick="find_contours('green1', 'out1', 'contours');">Find Green Contours</button>
                <button onclick="find_contours('blue1', 'out1', 'contours');">Find Blue Contours</button>
            </p>
            
            <canvas id="contours" style="border: black solid 1px;"></canvas>
            
        </blockquote> -->
        
        <!-- <h2>Draw Circle</h2>
        
        <blockquote>
        
            <p>Draw a circle on the picture:</p>
            
            <blockquote>
                
                X Location: <input type=text id='x' value='160' size='5'><br />
                Y Location: <input type=text id='y' value='120' size='5'><br />
                Radius: <input type=text id='radius' value='10' size='5'>

            </blockquote>
            
            <script>
                // use the text input for x, y, and radius
                // convert an input image to grayscale
                // and then draw a yellow circle on it at specified location
                function draw_circle(src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);

                    // get data from src canvas:
                    var dst = cv.imread(src_canvas_id);
                    // convert src to grayscale and then BACK to RGB (since going to draw on it in color)
                    cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    
                    // get circle info:
                    var x = parseInt(document.getElementById('x').value);
                    var y = parseInt(document.getElementById('y').value);
                    var center = new cv.Point(x, y); // create a point
                    var radius = parseInt(document.getElementById('radius').value);
                    
                    // create yellow color (255, 255, 0, 255)
                    let yellow_color = new cv.Scalar(255, 255, 0, 255);
                    // draw the circle
                    cv.circle(dst, center, radius, yellow_color, 3); // thickness of 3
                    
                    // display image
                    cv.imshow(dst_canvas, dst);
                    // clean up tmp images created:
                    dst.delete();
                }
            </script>
            
            <p><button onclick="draw_circle('out1', 'out5');">Draw Circle</button></p>
            
            <canvas id="out5" style="border: black solid 1px;"></canvas>

        </blockquote> -->

        <h2>Draw circle with center at biggest radius detected circle</h2>
        
        <blockquote>

            <!-- <script>
                // going to use BINARY image created in previous step
                // find the coutours in the image
                // and then draw them (back onto the grayscale image)
                function draw_enclosing_circle(src_binary_id, src_canvas_id, dst_canvas_id) {
                    // set up dst canvas
                    var dst_canvas = document.getElementById(dst_canvas_id);
                    dst_canvas.setAttribute("width", output_width);
                    dst_canvas.setAttribute("height", output_height);
                    
                    // read in BINARY image
                    var binary_img = cv.imread(src_binary_id);
                    // make sure binary (convert to grayscale and threshold)
                    cv.cvtColor(binary_img, binary_img, cv.COLOR_RGBA2GRAY);
                    cv.threshold(binary_img, binary_img, 128, 255, cv.THRESH_BINARY);
                    // read in grayscale image
                    var dst = cv.imread(src_canvas_id);
                    // convert src to grayscale and then BACK to RGB (since going to draw on it in color)
                    cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                                    
                    // setup
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    var biggestVector = 0;
                    var biggestVectorRadius = 0;

                    // find contours
                    cv.findContours(binary_img, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                    console.log('- FOUND', contours.size(), 'contours');

                    // go through contours
                    if (contours.size() > 0) {
                        // we are going to draw the contours in YELLOW
                        // - create yellow color (255, 255, 0, 255)
                        let yellow_color = new cv.Scalar(255, 255, 0, 255);
                        // go through each contour:
                        for (var i=0; i<contours.size(); i++) {
                            //cv.drawContours(dst, contours, i, yellow_color, 2, cv.LINE_8, hierarchy, 100);
                            
                            // note: you can find the "minimum enclosing circle" around the contour
                            // see: https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html
                            let circle = cv.minEnclosingCircle(contours.get(i));
                            // this circle has:
                            // - location: circle.center
                            // - radius: circle.radius
                            // so if it's big (radius > 10) then print to console:
                            console.log(' - circle at', circle.center, 'has radius', circle.radius);

                            // finds biggest circle
                            if (circle.radius > biggestVectorRadius) {
                                biggestVector = i;
                                biggestVectorRadius = circle.radius;
                            }
                        }
                        
                        let biggestCircle = cv.minEnclosingCircle(contours.get(biggestVector));
                        var biggestCircleRadius = biggestCircle.radius;
                        var biggestCircleCenter = biggestCircle.center;
                        // console.log('type is', typeof(biggestCircleCenter))
                        // console.log(biggestCircleCenter.x)

                        console.log('biggest circle is', biggestVector, 'at', biggestCircleCenter, 'with radius', biggestCircleRadius);

                        // draws biggest circle on image
                        cv.circle(dst, biggestCircleCenter, biggestCircleRadius, yellow_color, 3); // thickness of 3
                        // draws center point
                        //cv.circle(dst, biggestCircleCenter, 1, yellow_color, 1); // thickness of 3
                        //draws cross at center
                        let point1 = new cv.Point(biggestCircleCenter.x - 3, biggestCircleCenter.y);
                        let point2 = new cv.Point(biggestCircleCenter.x + 3, biggestCircleCenter.y);
                        cv.line(dst, point1, point2, yellow_color, 1, cv.LINE_AA, 0);

                        let point3 = new cv.Point(biggestCircleCenter.x, biggestCircleCenter.y - 3);
                        let point4 = new cv.Point(biggestCircleCenter.x, biggestCircleCenter.y + 3);
                        cv.line(dst, point3, point4, yellow_color, 1, cv.LINE_AA, 0);



                    }
                    
                    // display image with contours
                    cv.imshow(dst_canvas, dst);
                    // clean up tmp images created:
                    binary_img.delete();
                    dst.delete();
                }
                
            </script> -->

            <p>
                <button onclick="display_frame('video', 'out1'); threshold_rgb('out1', 'red1', 'green1', 'blue1'); draw_enclosing_circle('red1', 'out1', 'bigCircle');">Analyze Red</button>
                <button onclick="display_frame('video', 'out1'); threshold_rgb('out1', 'red1', 'green1', 'blue1'); draw_enclosing_circle('green1', 'out1', 'bigCircle');">Analyze Green</button>
                <button onclick="display_frame('video', 'out1'); threshold_rgb('out1', 'red1', 'green1', 'blue1'); draw_enclosing_circle('blue1', 'out1', 'bigCircle');">Analyze Blue</button>
            </p>
            
            <canvas id="bigCircle" style="border: black solid 1px;"></canvas>
            
        </blockquote>
	</div>
</body>	